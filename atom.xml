<feed xmlns="http://www.w3.org/2005/Atom">
	<author>
		<name>
			David v.Knobelsdorff
		</name>
	</author>
	<title type="text">davidvonk.dev</title>
	<id>https://davidvonk.dev</id>
	<updated>2022-04-14T13:48:00Z</updated>
	<link href="https://davidvonk.dev/atom.xml" rel="self">
	</link>
	<entry>
		<title type="text">Backing up my saved articles</title>
		<id>https://davidvonk.dev/automation/backing-up-my-saved-articles</id>
		<link href="https://davidvonk.dev/automation/backing-up-my-saved-articles" rel="alternate">
		</link>
		<updated>2022-04-14T13:48:00Z</updated>
		<summary type="text">
			Describing my workflow how to automate backing up my saved articles from Instapaper
		</summary>
		<content type="html">
			&lt;h2&gt;
	What and why?
&lt;/h2&gt;
&lt;p&gt;
	I try to follow a lot of newsfeeds during a typical week. Most of these are of technical nature but I also enjoy some chess content as well. Typically I do not have enough time to dive deep into an article whenever I discover something interesting. Therefore I am a long time user of Instapaper, a read-it-later service you probably already have heard of. In the course of the last few years I saved multiple thousand articles there. When GDPR came around Instapaper was not accessible for a long time in Europe which led me to look around for different solutions. However none of the other solutions really did it for me (Pocket f.e) which is why I started to create my own project. Couple of years forward and I have multiple GitHub repositories with better and worse implementations of a read-it-later app. One of these implementations (Reading Time) even was available on the App Store for a couple of months but I realized that it was to much effort for me to maintain this app.
&lt;/p&gt;
&lt;p&gt;
	Meanwhile Instapaper became available in Europe again and I figured there wasn&apos;t an alternative I liked better. Since Instapaper has an export feature and I wanted to prevent to lose all my saved articles whenever Instapaper would close its doors I would regularly login to the Instapaper website, download a csv dump of my saved articles and persist this in a private GitHub repository of mine. This however was a cumbersome process to say the least.
&lt;/p&gt;
&lt;h2&gt;
	The Solution
&lt;/h2&gt;
&lt;p&gt;
	So I knew I wanted to use Instapaper and I wanted to export my saved articles on a regular basis to make sure I wouldn&apos;t loose any of my link history. I figured GitHub Actions would be ideal to do exactly that and as a bonus are completely free. To create a GitHub action you need to create a new yaml configuration in &lt;code&gt;your-repo/.github/workflows/your-workflow-name.yml&lt;/code&gt;. For me this looks like this:
&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;
	&lt;pre&gt;&lt;code class=&quot;language-yml&quot;&gt;name: Instapaper Export

on:
  schedule:
    - cron: &amp;quot;0 0 * * *&amp;quot;
  workflow_dispatch:

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3
    - name: Set up Python 3.9.12
      uses: actions/setup-python@v3
      with:
        python-version: &amp;quot;3.9.12&amp;quot;
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    - name: setup git config
      run: |
        git config user.name &amp;quot;David v.Knobelsdorff&amp;quot;
        git config user.email &amp;quot;youremail@email-address.com&amp;quot;
    - name: run export script
      run: |
        INSTAPAPER_PASSWORD=${{ secrets.INSTAPAPER_PASSWORD }} python export-instapaper.py --archive
    - name: commit
      run: |
        git add -A
        (git commit -m &amp;quot;update instapaper export&amp;quot; &amp;amp;&amp;amp; git push origin master) || echo &amp;quot;No changes to commit&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/figure&gt;
&lt;p&gt;
	The cron parameter specifies that this action runs daily at midnight. To login into Instapaper I need my password which is passed via a secret environment variable. You can specifiy those in your repos settings. Last but not least the workflow runs my python script export-instapaper.py and pushes any changed files to remote.
&lt;/p&gt;
&lt;p&gt;
	GitHub Actions made this automation super simple and I highly recommend checking it out if you haven&apos;t. You even get an E-Mail notification should an action fail.
&lt;/p&gt;
&lt;h2&gt;
	The actual script &amp; archiving
&lt;/h2&gt;
&lt;p&gt;
	What is left is the implementation of the actual script. Probably this is what you came for, right?
	
	Without any further ado here it is:
&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;
	&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;#!/usr/bin/env python3

import logging
import sys
import json
import os
import argparse
import html
import requests
import keyring
import csv
import collections
import io
from html.parser import HTMLParser
from waybackpy import WaybackMachineSaveAPI

parser = argparse.ArgumentParser(description=&amp;apos;export instapaper bookmarks&amp;apos;)
parser.add_argument(&amp;quot;--archive&amp;quot;, action=&amp;quot;store_true&amp;quot;)
args = parser.parse_args()


class GetFormkeyParser(HTMLParser):
    def handle_starttag(self, tag, attrs):
        if tag == &amp;apos;input&amp;apos;:
            attrs = dict(attrs)
            if attrs.get(&amp;apos;name&amp;apos;) == &amp;apos;form_key&amp;apos;:
                self.form_key = attrs[&amp;apos;value&amp;apos;]

    @classmethod
    def get_form_key(cls, html):
        parser = cls()
        parser.feed(html)
        return parser.form_key


def export_instapaper(fmt=&amp;apos;csv&amp;apos;):
    assert fmt in (&amp;apos;html&amp;apos;, &amp;apos;csv&amp;apos;)

    s = requests.Session()
    username = &amp;apos;your username&amp;apos;
    password = keyring.get_password(&amp;apos;https://instapaper.com&amp;apos;, username) or os.environ[&amp;apos;INSTAPAPER_PASSWORD&amp;apos;]

    if password is None:
        raise Exception(&amp;quot;you need to set a password&amp;quot;)

    req = s.post(&amp;quot;https://www.instapaper.com/user/login&amp;quot;,
                 data={&amp;apos;username&amp;apos;: username,
                       &amp;apos;password&amp;apos;: password})

    if req.status_code != 200:
        req.raise_for_status()

    req = s.get(&amp;quot;https://www.instapaper.com/user&amp;quot;)

    if req.status_code != 200:
        req.raise_for_status()

    form_key = GetFormkeyParser.get_form_key(req.content.decode(&amp;apos;utf8&amp;apos;))

    req = s.post(&amp;quot;https://www.instapaper.com/export/{}&amp;quot;.format(fmt), data={&amp;apos;form_key&amp;apos;:form_key})

    if req.status_code != 200:
        req.raise_for_status()

    return req.content.decode(&amp;apos;utf8&amp;apos;)

new_content = export_instapaper()

if args.archive:
    old_file = open(&amp;apos;instapaper-export.csv&amp;apos;, &amp;apos;r&amp;apos;)
    old = csv.DictReader(old_file)
    new = csv.DictReader(io.StringIO(new_content))

    old_urls = []
    new_urls = []

    for col in old:
        old_urls.append(col[&amp;apos;URL&amp;apos;])

    for col in new:
        new_urls.append(col[&amp;apos;URL&amp;apos;])

    urls_to_save = set(new_urls) - set(old_urls)
    user_agent = &amp;quot;Mozilla/5.0 (Windows NT 5.1; rv:40.0) Gecko/20100101 Firefox/40.0&amp;quot;

    # You might want to filter urls even further. f.e do not try to archive youtube urls
    for url in urls_to_save:
        print(&amp;quot;Archiving {}&amp;quot;.format(url))
        save_api = WaybackMachineSaveAPI(url, user_agent)
        save_api.save()

file = open(&amp;apos;instapaper-export.csv&amp;apos;, &amp;apos;w&amp;apos;)
file.write(new_content)
file.close()

html_file = open(&amp;apos;instapaper-export.html&amp;apos;, &amp;apos;w&amp;apos;)
html_file.write(export_instapaper(fmt=&amp;apos;html&amp;apos;))
html_file.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;/figure&gt;
&lt;p&gt;
	Basically this authenticates on the Instapaper website, grabs the form field &quot;form_key&quot; (some csrf token) and triggers the export endpoint via HTTP POST.
&lt;/p&gt;
&lt;p&gt;
	As a bonus I added a command line argument &quot;archive&quot;. If present the script will compare the exported links to links exported previously. All newly added urls are saved to the &lt;a href=&quot;https://archive.org&quot;&gt;Internet Archive&lt;/a&gt; via the third-party library &lt;a href=&quot;https://github.com/akamhy/waybackpy&quot;&gt;waybackpy&lt;/a&gt;. This way even if Instapaper shuts down I have a complete list of all articles I read or want to read and I will also find a snapshot of the website on the internet archive if one of the articles isn&apos;t reachable anymore.
&lt;/p&gt;
&lt;p&gt;
	Last but not least I also export all links in the HTML format Instapaper offers to maximize compatibility with other services (f.e Pocket only allows to import Instapaper articles from an HTML export).
&lt;/p&gt;
&lt;h2&gt;
	Conclusion
&lt;/h2&gt;
&lt;p&gt;
	This script is running for a couple of days now and I had no trouble since. I am pretty happy with the workflow now and use Instapaper on a daily basis without worrying over loosing all my links or being unable to read an article because the website shut down or the article was deleted. If you want to try it yourself I am happy to hear from you.
&lt;/p&gt;
		</content>
	</entry>
	<entry>
		<title type="text">Generating licenses for SPM dependencies</title>
		<id>https://davidvonk.dev/swift/generating-licenses-for-spm-dependencies</id>
		<link href="https://davidvonk.dev/swift/generating-licenses-for-spm-dependencies" rel="alternate">
		</link>
		<updated>2020-12-24T22:15:00Z</updated>
		<summary type="text">
			A quick overview how to generate licenses for SPM dependencies
		</summary>
		<content type="html">
			&lt;h1&gt;
	Generating licenses for SPM dependencies
&lt;/h1&gt;
&lt;p&gt;
	Chances are your are using Swift Package Manager, at least to some degree, in your (i(Pad)?|mac|tv|watch)OS app. Since the first class support in Xcode was added it definetly is my favourite tool to handle dependencies for apps in the Apple ecosystem.
&lt;/p&gt;
&lt;p&gt;
	As app developers we have to deal with a lot of stuff besides the actual development of features like setting up CI, supporting our customers etc. If you happen to use third party dependencies one of these tasks probably will be to include various Open Source licenses in your application. Having used well known alternatives like Carthage and Cocoapods before SPM was a thing I encountered plugins for these tools to automate this for me. Not only is this approach keeping work from me for every new project I fire up in Xcode, it also wonâ€™t forget to include a license for every dependency that is added. I canâ€™t say that confidently about myself.
&lt;/p&gt;
&lt;p&gt;
	To avoid copying each license html manually like an animal I did a quick search for available tools for SPM and I found some. But none of them fitted my requirements exactly. Here is a list of possibilities for you:
&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
		&lt;p&gt;&lt;a href=&quot;https://github.com/nicklockwood/Tribute&quot;&gt;Tribute&lt;/a&gt;&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;p&gt;&lt;a href=&quot;https://github.com/mono0926/LicensePlist&quot;&gt;LicensePlist&lt;/a&gt;&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;p&gt;&lt;a href=&quot;https://github.com/carloe/LicenseGenerator-iOS&quot;&gt;LicenseGenerator-iOS&lt;/a&gt;&lt;/p&gt;
	&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
	Since I couldnâ€™t find a perfect solution to my problem I thought it would be a fun exercise to build a tool by myself. Also, to be honest, it was a great excuse to get my hands on the recently released &lt;a href=&quot;https://github.com/apple/swift-argument-parser&quot;&gt;swift-argument-parser&lt;/a&gt;. You can find the project on GitHub, itâ€™s called &lt;a href=&quot;https://github.com/dehlen/SPMLicenses&quot;&gt;SPMLicenses&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;
	To set some expectations upfront: It hardly is a v1.0.0. I used it in two projects of mine now and it worked fine for me but I canâ€˜t promise to build a full featured tool out of this. On the other hand it is Open Source so if there is something missing or not working for you spin up Xcode and a debugger and build a tool that fits your needs.
&lt;/p&gt;
&lt;p&gt;
	How does it work? SPMLicenses fetches all your third party dependencies from a Package.resolved file which is created and updated by Xcode. It further tries to find the GitHub url of the dependencies and fetches the license from the GitHub API. The result will then be written to a json file. There are at least two problems with this approach:
&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;
		&lt;p&gt;
			If you use packages which arenâ€™t hosted on GitHub they wonâ€˜t be included in the json
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;p&gt;
			You can get rate limited (60 requests per hour) for making to many API requests when running this on CI f.e
		&lt;/p&gt;
	&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;
	No 2. is addressed by the fact that you can specify GitHub credentials when generating your license json. This way you wonâ€˜t get rate limited that easily (5000 requests per hour). It also makes sure you can access private repositories to fetch their licenses.
	
	To register a GitHub application please follow this link: &lt;a href=&quot;https://github.com/settings/developers&quot;&gt;https://github.com/settings/developers&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;
	There are ideas to fix No 1. but as I said above: it hardly is a v1.0.0. For my current use case limiting the tool to GitHub only is totally fine. If you need something different I highly recommend using &lt;a href=&quot;https://github.com/nicklockwood/Tribute&quot;&gt;Tribute&lt;/a&gt; from Nick Lockwood. It definitely seems like the tool I want to use but unfortunately it is lacking SPM support at the time of this writing.
&lt;/p&gt;
&lt;p&gt;
	All of the above is expressed by a single call on your command line:
&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;
	&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;$ swift run spm-licenses &amp;lt;path to .xcworkspace&amp;gt; &amp;lt;output.json&amp;gt; &amp;lt;optional GitHub client id&amp;gt; &amp;lt;optional GitHub client secret&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/figure&gt;
&lt;p&gt;
	If you want to tinker with it or use the tool in one of your applications you can build SPMLicenses from source like so:
&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;
	&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;$ swift build -c release
$ cd .build/release
$ cp -f spm-licenses /usr/local/bin/spm-licenses
&lt;/code&gt;&lt;/pre&gt;
&lt;/figure&gt;
&lt;p&gt;
	Or use &lt;a href=&quot;https://github.com/yonaskolb/Mint&quot;&gt;Mint&lt;/a&gt;:
&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;
	&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;$ mint install dehlen/SPMLicenses
&lt;/code&gt;&lt;/pre&gt;
&lt;/figure&gt;
&lt;p&gt;
	If you want to update the license file on every Xcode build you can add this simple script as a Run Script Build Phase. To set this up in Xcode, do the following:
&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;
		&lt;p&gt;
			Click on your project in the file list, choose your target under TARGETS, click the Build Phases tab
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;p&gt;
			Add a New Run Script Phase by clicking the little plus icon in the top left and paste in the following script:
		&lt;/p&gt;
	&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;
	&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;if which spm-licenses &amp;gt;/dev/null; then
 spm-licenses &amp;lt;path to .xcworkspace&amp;gt; &amp;lt;output.json&amp;gt; &amp;lt;optional GitHub client id&amp;gt; &amp;lt;optional GitHub client secret&amp;gt;
else
  echo &amp;quot;warning: SPMLicenses not installed, download from https://github.com/dehlen/SPMLicenses&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;
&lt;/figure&gt;
&lt;p&gt;
	To wrap things up you can use this SwiftUI module to automatically render the generated licenses in your app:
&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;
	&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;import Foundation
import SwiftUI
import os

struct License: Codable, Identifiable {
    let licenseName: String
    let licenseText: String
    let packageName: String
    
    var id: String { packageName }
}

extension License {
    static let mock: License = .init(licenseName: &amp;quot;MIT&amp;quot;, licenseText: &amp;quot;MIT license text&amp;quot;, packageName: &amp;quot;Test Dependency&amp;quot;)
}

final class LicensesViewModel: ObservableObject {
    @Published private(set) var licenses: [License] = []
    #warning(&amp;quot;update subsystem string&amp;quot;)
    private let logger = Logger(subsystem: &amp;quot;com.sample.app&amp;quot;, category: String(describing: LicensesViewModel.self))

    init() {
        #warning(&amp;quot;make sure licenses.json is added to the project&amp;quot;)
        guard let url = Bundle.main.url(forResource: &amp;quot;licenses&amp;quot;, withExtension: &amp;quot;json&amp;quot;) else {
            logger.debug(&amp;quot;Could not read licenses because file does not exist.&amp;quot;)
            return
        }

        do {
            let data = try Data(contentsOf: url)
            self.licenses = try JSONDecoder().decode([License].self, from: data)
        } catch {
            logger.debug(&amp;quot;Could not read licenses: \(error.localizedDescription, privacy: .public)&amp;quot;)
        }
    }
}

struct LicensesView: View {
    @ObservedObject var viewModel: LicensesViewModel

    var body: some View {
        List(viewModel.licenses) { license in
            LicenseView(license: license)
        }.navigationBarTitle(Text(&amp;quot;Licenses&amp;quot;), displayMode: .inline)
    }
}

struct LicensesView_Previews: PreviewProvider {
    static var previews: some View {
        LicensesView(viewModel: .init())
    }
}

struct LicenseView: View {
    let license: License
    var body: some View {
        NavigationLink(destination: LicenseDetailView(license: license)) {
            HStack {
                Text(license.packageName)
                    .font(.body)
                Spacer()
                Text(license.licenseName)
                    .font(.body)
                    .foregroundColor(Color(.secondaryLabel))
            }
        }
    }
}

struct LicenseView_Previews: PreviewProvider {
    static var previews: some View {
        LicenseView(license: .mock)
    }
}

struct LicenseDetailView: View {
    let license: License
    
    var body: some View {
        ScrollView {
            VStack {
                Text(license.licenseText)
                Spacer()
            }.padding()
        }.navigationBarTitle(Text(license.packageName), displayMode: .inline)
    }
}

struct LicenseDetailView_Previews: PreviewProvider {
    static var previews: some View {
        LicenseDetailView(license: .mock)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/figure&gt;
		</content>
	</entry>
	<entry>
		<title type="text">When your macOS application is about to quit</title>
		<id>https://davidvonk.dev/macos/when-your-macos-application-is-about-to-quit</id>
		<link href="https://davidvonk.dev/macos/when-your-macos-application-is-about-to-quit" rel="alternate">
		</link>
		<updated>2020-05-01T10:13:00Z</updated>
		<summary type="text">
			Familiarize yourself with the NSApplication.TerminateReply API
		</summary>
		<content type="html">
			&lt;h2&gt;
	Executing work before the application quits
&lt;/h2&gt;
&lt;p&gt;
	A quick Google search on &lt;code&gt;NSApplication.TerminateReply&lt;/code&gt; results in 328 results. I can&apos;t think of many search phrases which perform worse.
&lt;/p&gt;
&lt;div class=&quot;image&quot;&gt;
	&lt;img alt=&quot;An image showing a google search for NSApplication.TerminateReply.&quot; loading=&quot;lazy&quot; src=&quot;/img/terminate-reply/NSApplication-TerminateReply-Google-Search.png&quot; width=&quot;463.5&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;
	In my Text Editor &lt;em&gt;Caret&lt;/em&gt; I am not able to use Apples &lt;code&gt;NSDocument&lt;/code&gt; class, or at least, I found, it probably isn&apos;t the best idea for my use case. However &lt;code&gt;NSDocument&lt;/code&gt; comes with a neat little feature I knew I needed to support: &lt;strong&gt;Autosaving changes&lt;/strong&gt;. Whenever a user edits text in the text editor the changes should be reflected on disk. Of course I do everything to coordinate these file changes and to have a reliable mechanism but to be extra sure I wanted to save all pending file changes before the application quits. Turns out this is what &lt;code&gt;NSApplication.TerminateReply&lt;/code&gt; is for.
&lt;/p&gt;
&lt;h3&gt;
	Info.plist setup
&lt;/h3&gt;
&lt;p&gt;
	First you most certainly want to set the following key in your &lt;code&gt;Info.plist&lt;/code&gt;:
&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;
	&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;!DOCTYPE plist PUBLIC &amp;quot;-//Apple//DTD PLIST 1.0//EN&amp;quot; &amp;quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&amp;quot;&amp;gt;
&amp;lt;plist version=&amp;quot;1.0&amp;quot;&amp;gt;
&amp;lt;dict&amp;gt;
	&amp;lt;key&amp;gt;NSSupportsSuddenTermination&amp;lt;/key&amp;gt;
	&amp;lt;false/&amp;gt;
&amp;lt;/dict&amp;gt;
&amp;lt;/plist&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/figure&gt;
&lt;p&gt;
	Otherwise it can happen that &lt;code&gt;applicationShouldTerminate&lt;/code&gt; won&apos;t being called and &lt;code&gt;NSApplicationWillTerminateNotification&lt;/code&gt; won&apos;t being sent. With that out of our mind let&apos;s dive into using the above API.
&lt;/p&gt;
&lt;h3&gt;
	AppDelegate implementation
&lt;/h3&gt;
&lt;p&gt;
	You might start by doing all your saving logic in
&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;
	&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;func applicationWillTerminate(_ aNotification: Notification) {
  // Insert code here to tear down your application
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;/figure&gt;
&lt;p&gt;
	Unfortunately this won&apos;t work since, after all, the application will terminate. If your operation is taking enough time to finish you&apos;ll end up with a terminated process and no saved changes.
&lt;/p&gt;
&lt;p&gt;
	To fix this we need to implement &lt;code&gt;applicationShouldTerminate(_ sender: NSApplication) -&amp;gt; NSApplication.TerminateReply&lt;/code&gt;.
	&lt;code&gt;NSApplication.TerminateReply&lt;/code&gt; actually is an enum and can either be:
&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
		&lt;p&gt;
			terminateCancel
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;p&gt;
			terminateNow
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;p&gt;
			terminateLater
		&lt;/p&gt;
	&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;terminateCancel&lt;/code&gt; will stop the termination of the application. This isn&apos;t a pleasant user experience since the user wanted to quit you app. Interesting however is &lt;code&gt;terminateNow&lt;/code&gt; and &lt;code&gt;terminateLater&lt;/code&gt;. When you do not have any pending file changes you can quit right away by returning &lt;code&gt;terminateNow&lt;/code&gt;, but when you do have changes &lt;code&gt;terminateLater&lt;/code&gt; is what you want.
&lt;/p&gt;
&lt;p&gt;
	Start by implementing something like the following logic in your AppDelegate:
&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;
	&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;func applicationShouldTerminate(_ sender: NSApplication) -&amp;gt; NSApplication.TerminateReply {
    if hasPendingChanges {
        savePendingChanges()
	return .terminateLater
    }

    return .terminateNow
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/figure&gt;
&lt;p&gt;
	When you run your app in this state and quit it with pending changes the application won&apos;t be terminated. Whats left is to tell the process when you actually finished your save operation in order to terminate the application.
	
	Luckily for us there is API to do exactly that: &lt;code&gt;NSApp.reply(toApplicationShouldTerminate: true)&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;
	To round things up this is how your &lt;code&gt;savePendingChanges&lt;/code&gt; method should look like:
&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;
	&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;func savePendingChanges() {
    doSomeWork {
        NSApp.reply(toApplicationShouldTerminate: true)
    }
}
``

### Conclusion
Doing work just before the application quits actually is pretty straightforward to implement on macOS. One common pitfall is to miss the Info.plist entry I mentioned at the beginning of the post. Of course, just because this option exists, you probably do not want to run operations which take a long time. This inevitably will lead to bad UX for your customers. Try to save as often as you can without sacrificing performance or user experience of your application. By implementing the pattern explained in this blog post you will make sure to provide a reliable experience for your users.
&lt;/code&gt;&lt;/pre&gt;
&lt;/figure&gt;
		</content>
	</entry>
	<entry>
		<title type="text">Sandbox on macOS</title>
		<id>https://davidvonk.dev/macos/sandbox-on-macos</id>
		<link href="https://davidvonk.dev/macos/sandbox-on-macos" rel="alternate">
		</link>
		<updated>2020-04-30T19:45:00Z</updated>
		<summary type="text">
			File system access in a sandboxed macOS application
		</summary>
		<content type="html">
			&lt;h2&gt;
	File System access in a sandboxed macOS application
&lt;/h2&gt;
&lt;p&gt;
	While the sandbox is great for consumers and the overall security on Apples platforms it can be quite frustrating to deal with. On macOS, in comparison to iOS, this gets even worse since you are more likely to deal with the file system and other sandbox related resources of the system. Unfortunately as soon as you plan to sell your application in the Mac App Store this is the only option you have. Part of developing my upcoming Text Editor &lt;em&gt;Caret&lt;/em&gt; was to read and write markdown and plain text files from/to disk so doing the whole sandbox dance was without any alternative.
&lt;/p&gt;
&lt;h3&gt;
	How hard can it be?
&lt;/h3&gt;
&lt;p&gt;
	First things first you probably start by looking into the &lt;a href=&quot;https://developer.apple.com/documentation/foundation/filemanager&quot;&gt;FileManager&lt;/a&gt; API to access the file system. By quickly browsing through the available API it looks like we are in the right spot for our requirement. ðŸ”‹ Batteries included. To get a list of files in a specific folder one only has to write these simple couple of lines, right?:
&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;
	&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;let url = URL(fileURLWithPath: &amp;quot;/path/to/folder&amp;quot;) 
let fileURLs = try FileManager.default.contentsOfDirectory(at: url,
    includingPropertiesForKeys: nil,
    options: .skipsHiddenFiles)
&lt;/code&gt;&lt;/pre&gt;
&lt;/figure&gt;
&lt;p&gt;
	This works fine as long as you specify a folder outside of the applications sandbox. Every macOS application creates a sandbox with a dedicated &lt;em&gt;Documents&lt;/em&gt; directory for example.
&lt;/p&gt;
&lt;div class=&quot;image&quot;&gt;
	&lt;img alt=&quot;An image of a Finder window showing the sandbox directories content.&quot; loading=&quot;lazy&quot; src=&quot;/img/sandbox/Sandbox-Directory.png&quot; width=&quot;463.5&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;
	But what about the users &lt;em&gt;Documents&lt;/em&gt; directoy at &lt;code&gt;$HOME/Documents&lt;/code&gt;? Trying to read files from this directory will yield an error. The user did not grant any permission to read this directory. This is great for us as a consumer but how do we deal with this from a developers perspective?
&lt;/p&gt;
&lt;h3&gt;
	Full-Disk Permission
&lt;/h3&gt;
&lt;p&gt;
	There are a handful of options we have right now. We could ask the user for Full-Disk Permission. This would certainly make our life easier, but lets be honest: We probably would delete the app right away as a consumer.
&lt;/p&gt;
&lt;div class=&quot;image&quot;&gt;
	&lt;img alt=&quot;An image of System settings showing how to configure the full disk permission setting.&quot; loading=&quot;lazy&quot; src=&quot;/img/sandbox/Full-Disk-Permission.png&quot; width=&quot;463.5&quot;/&gt;
&lt;/div&gt;
&lt;h3&gt;
	Disabling Sandbox
&lt;/h3&gt;
&lt;p&gt;
	We could also disable the sandbox but then we wonâ€™t be able to sell our application through Apples Mac App Store (as stated above). So not a great option either.
&lt;/p&gt;
&lt;h3&gt;
	NSOpenPanel
&lt;/h3&gt;
&lt;p&gt;
	Next there is the possibility to ask the user for permission to access the specific folder before trying to read or write files. This actually is the right way to do it and &lt;code&gt;NSOpenPanel&lt;/code&gt; already handles this for us. However to use this we need to configure our Xcode project first. Go to &lt;code&gt;General â€”&amp;gt; Target â€”&amp;gt; App Sandbox â€”&amp;gt; User Selected File&lt;/code&gt; and select &lt;em&gt;Read/Write&lt;/em&gt;.
&lt;/p&gt;
&lt;div class=&quot;image&quot;&gt;
	&lt;img alt=&quot;An image of an Xcode project showing how to configure the project to read and write files.&quot; loading=&quot;lazy&quot; src=&quot;/img/sandbox/Project-Configuration.png&quot; width=&quot;463.5&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;
	Xcode will now create an entitlements file and sets the correct .plist entries for you. To prompt the user to select a directory we now finally can request an &lt;code&gt;NSOpenPanel&lt;/code&gt; like so:
&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;
	&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;func requestPermission(then handler: @escaping (URL?) -&amp;gt; Void) {
    let openPanel = NSOpenPanel()
    openPanel.message = &amp;quot;Choose your directory&amp;quot;
    openPanel.prompt = &amp;quot;Choose&amp;quot;
    openPanel.allowsMultipleSelection = false
    openPanel.canChooseDirectories = true
    openPanel.canCreateDirectories = true
    openPanel.canChooseFiles = false
    openPanel.begin { (result) -&amp;gt; Void in
        if result == .OK {
            handler(openPanel.urls.first)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/figure&gt;
&lt;p&gt;
	Invoking the FileManager API after an user selected an URL in the presented &lt;code&gt;NSOpenPanel&lt;/code&gt; will return the expected results. Yay!
&lt;/p&gt;
&lt;p&gt;
	Thatâ€™s it for todays post. Thank you very much for joining me on this and ... wait. Of course this wasnâ€™t the whole thing. There has to be some caveat for making implementing sandbox on macOS a theme for a blog post, right? Actually the granted permission from the selected folder wonâ€™t be persisted. Whenever the application relaunches we will have to ask for permission again. The solution to this problem are &lt;code&gt;Security-Scoped Bookmarks&lt;/code&gt;. At this point we probably already read the whole abstract on the macOS sandbox over at &lt;a href=&quot;https://developer.apple.com/library/archive/documentation/Security/Conceptual/AppSandboxDesignGuide/AboutAppSandbox/AboutAppSandbox.html&quot;&gt;App Sanbox Quick Start&lt;/a&gt;, just to find this massive, complex abstract:
	&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/Security/Conceptual/AppSandboxDesignGuide/AppSandboxInDepth/AppSandboxInDepth.html&quot;&gt;App Sandbox in Depth&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;
	Luckily for you, you can just proceed reading this blog post to get the gist of it and to finally implement macOS sandboxing (for real!).
&lt;/p&gt;
&lt;h3&gt;
	Security-Scoped Bookmarks
&lt;/h3&gt;
&lt;p&gt;
	The concept is fairly simple. Whenever you get access to a new location outside of your apps sandbox you want to store the URL as serialized data in a persistent store(UserDefaults/.plist are good options here). When the application is launched we try to read back the saved data. In practice URL bookmarks can be marked as stale and they need to be refreshed. Your implementation will need to handle this case, otherwise the bookmark will be unusable at some point.
&lt;/p&gt;
&lt;h4&gt;
	Storing a bookmark
&lt;/h4&gt;
&lt;p&gt;
	To store a bookmark we will use
&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;
	&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;func saveBookmark(for url: URL) {
    let data = try url.bookmarkData(options: .withSecurityScope, includingResourceValuesForKeys: nil, relativeTo: nil)
    // persist data somewhere
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/figure&gt;
&lt;p&gt;
	You most certainly want to call this in the completion block of your &lt;code&gt;NSOpenPanel&lt;/code&gt;. The returned data then can be stored in your persistent container. By calling this in the completion block of the &lt;code&gt;NSOpenPanel&lt;/code&gt; we make sure the bookmark data will be written when we launch the application the next time.
&lt;/p&gt;
&lt;h4&gt;
	Reading and refreshing a bookmark
&lt;/h4&gt;
&lt;p&gt;
	Reading a bookmark is fairly simple as well. We can leverage an already existing initializer of &lt;code&gt;Foundation.URL&lt;/code&gt;:
&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;
	&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;func restoreBookmark(with bookmarkData: Data) -&amp;gt; URL? {
	do {
		var isStale = false
		let url = try URL(resolvingBookmarkData: bookmarkData, options: .withSecurityScope, relativeTo: nil, bookmarkDataIsStale: &amp;amp;isStale)

		if isStale {
	  	saveBookmark(for: url)
		}
		
		return url
	} catch {
		debugPrint(error)
		return nil
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/figure&gt;
&lt;p&gt;
	As I already mentioned a persisted bookmark can be marked as stale. When this happens we need to refresh it by invoking our &lt;code&gt;saveBookmark&lt;/code&gt; function once again. At this point we are nearly finished, although the above solution still wonâ€™t work. In order to really access the bookmarked URL we need to start requesting access to it, before doing any read/write operation.
&lt;/p&gt;
&lt;h3&gt;
	Start / Stop Requesting Access
&lt;/h3&gt;
&lt;p&gt;
	When weâ€™re ready to read files, weâ€™ll have to wrap this in a pair of calls to signal that we want to access the resource:
&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;
	&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;defer { url.stopAccessingSecurityScopedResource() }
if !url.startAccessingSecurityScopedResource() {
    print(&amp;quot;startAccessingSecurityScopedResource returned false. This directory might not need it, or this URL might not be a security scoped URL, or maybe somethingâ€™s wrong?&amp;quot;)
}
// do your file operation
&lt;/code&gt;&lt;/pre&gt;
&lt;/figure&gt;
&lt;p&gt;
	Here we call startAccessingSecurityScopedResource on the URL weâ€™ve been given. This might return false  under a few conditions:
&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
		&lt;p&gt;
			The user really doesnâ€™t have access to this
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;p&gt;
			The URL isnâ€™t a security scoped URL
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;p&gt;
			This directory doesnâ€™t need it, f.e &lt;code&gt;$HOME/Downloads&lt;/code&gt;&lt;/p&gt;
	&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
	In most situations, like accessing the Downloads folder, you are probably safe to just log the result, like in the code snippet above, and to continue.
&lt;/p&gt;
&lt;h4&gt;
	Providing a wrapper
&lt;/h4&gt;
&lt;p&gt;
	Of course we do not want to introduce code duplication into our perfectly structured, highly optimized codebase :) So it sounds like a good plan to introduce a wrapper in order to abstract this complexity away from our buisness logic. Also it might be a good idea to store bookmarks in a dictionary &lt;code&gt;[URL: Data]&lt;/code&gt; to be able to store multiple bookmarks our application then has persisted access to. I published a gist at:
	&lt;a href=&quot;https://gist.github.com/dehlen/1fce47792bc4ef676557947895be2ccd&quot;&gt;SandboxDirectoryAccess.swift&lt;/a&gt; and I invite you to use it, no questions asked.
&lt;/p&gt;
&lt;h3&gt;
	Conclusion
&lt;/h3&gt;
&lt;p&gt;
	When you made it that far, congratulations. You earned yourself some time to take a break.
	
	However at some point you probably want to start to comply with Apples recommendation and wrap all your file system calls in a &lt;a href=&quot;https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileCoordinators/FileCoordinators.html&quot;&gt;FileCoordinator&lt;/a&gt; to make sure your read and write operations are properly coordinated throughout the system. Iâ€™ll provide an extensive guide on this topic on another day.
&lt;/p&gt;
		</content>
	</entry>
</feed>